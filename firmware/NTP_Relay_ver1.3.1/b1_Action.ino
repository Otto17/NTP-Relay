//********** ДЕЙСТВИЯ ОТ КОНСТРУКТОРА САЙТА **********//



//Функция с действиями от WEB интерфейса
void action() {

  //Условия проверкина нажатия и отпускания WEB кнопок
  if (ui.hold()) {  // Вернёт true, если статус удержания кнопки изменился (нажата/отпущена)

    //Обработка кнопки "Синхронизация NTP"
    if (ui.clickUp("NTP_YA_upd")) {  // Вернёт true, если кнопка была нажата и отпущена
      ntp.updateNow();               // Вручную запрашиваем и обновляем время с сервера NTP
      flag_YA = true;                // Поднимаем флаг, тем самым принудительно запрашиваем JSON файл с Яндекса
    }
  }



  //Если одна из форм была submit...
  if (ui.form()) {

    //Проверка и обработка данных с формы установки времени
    if (ui.form("/install")) {  // Проверяем, была ли это форма "/ssid_pass"

      ui.copyTime("timeOn", pool_TimeOn);    // Копируем данные из запроса "timeOn" в переменную "valTimeOn"
      ui.copyTime("timeOff", pool_TimeOff);  // Копируем данные из запроса "timeOff" в переменную "valTimeOff"

      //Преобразуем в строку вида: hh:mm:ss
      String enc_TimerOn = pool_TimeOn.encode();
      String enc_TimerOff = pool_TimeOff.encode();


      //Блок "String to const char*" для корректного перевода строки в массив символов. Необходим для функции "sscanf()"
      //Для переменной "enc_TimerOn" - начало работы реле
      char BufOn[sizeof(enc_TimerOn)];                                  // Создаём буфер и вычисляем его размер
      enc_TimerOn.toCharArray(BufOn, sizeof(enc_TimerOn));              // myString.toCharArray(buf, len) – записывает строку в массив – буфер BufOn (типа char []) с начала и до длины len.
      const char* TimerOn = enc_TimerOn.c_str();                        // Возвращаем указатель на массив символов "enc_TimerOn" с завершающим нулем
      sscanf(TimerOn, "%2d:%2d:%2d", &Start_hh, &Start_mm, &Start_ss);  // Конвертируем строку "чч:мм:сс" по маске в числа и пишем в разные переменные. Маска: "%2d:%2d:%2d" - первые два числа пишем в "Start_hh", двоеточия отсеиваем и от них ещё два числа пишем в "Start_mm" и так же с секундами

      //Для переменной "enc_TimerOff" - окончание работы реле
      char BufOff[sizeof(enc_TimerOff)];                           // Создаём буфер и вычисляем его размер
      enc_TimerOff.toCharArray(BufOff, sizeof(enc_TimerOff));      // myString.toCharArray(buf, len) – записывает строку в массив – буфер BufOff (типа char []) с начала и до длины len.
      const char* TimerOff = enc_TimerOff.c_str();                 // Возвращаем указатель на массив символов "enc_TimerOff" с завершающим нулем
      sscanf(TimerOff, "%2d:%2d:%2d", &End_hh, &End_mm, &End_ss);  // Конвертируем строку "чч:мм:сс" по маске в числа и пишем в разные переменные. Маска: "%2d:%2d:%2d" - первые два числа пишем в "End_hh", двоеточия отсеиваем и от них ещё два числа пишем в "End_mm" и так же с секундами


      //Переводим часы, минуты и секунды в одно число (секунды) для удобной работы с этим числом секунд и записи его в EEPROM
      Start_str = (Start_hh * 3600) + (Start_mm * 60) + Start_ss;  // Перевод времени начала работы реле
      End_str = (End_hh * 3600) + (End_mm * 60) + End_ss;          // Перевод времени окончания работы реле


      //Сохраняем заданное время в EEPROM
      EEPROM.begin(EEPROM_BEGIN);  // Инициализируем EEPROM
      EEPROM.put(80, Start_str);   // Подготавливаем к записи с 80 ячейки переменную начала работы реле (сохраняем её в ОЗУ)
      EEPROM.put(100, End_str);    // Подготавливаем к записи с 100 ячейки переменную окончания работы реле (сохраняем её в ОЗУ)
      EEPROM.commit();             // Записываем из ОЗУ в EEPROM
      EEPROM.end();                // И очищаем данные из ОЗУ
    }
  }



  //Условия проверки нажатия кнопкок на обновление
  if (ui.update()) {  // Проверка на update, вернёт true, если было обновление

    //Проверка на обновление - Перезагрузка ESP
    //Вызов обновления с WEB кнопки "Перезагрузить ESP". Нужно для вывода информирования с подтверждением, при случайном нажатии кнопки
    if (ui.update("inf_rebootESP")) {  // Если было обновление с компонента "inf_rebootESP", то
      ui.answer(1);                    // Отправляем в ответ на обновление число 1
    }

    //Проверка на обновление - Сброс настроек ESP
    //Вызов обновления с WEB кнопки "Сброс настроек ESP". Нужно для вывода информирования с подтверждением, при случайном нажатии кнопки
    if (ui.update("inf_resetESP")) {  // Если было обновление с компонента "inf_resetESP", то
      ui.answer(1);                   // Отправляем в ответ на обновление число 1
    }
  }



  //Условия проверки на клика (кнопка, чекбокс, свитч, слайдер, селектор)
  if (ui.click()) {  // Проверка кнопок на клики

    //Выполняем действие после нажатия "ДА" на информ. окне - Перезагрузка ESP
    if (ui.click("inf_rebootESP")) {              // Вернёт true, если был клик по кнопке информационного окошка "inf_rebootESP"
      if (ui.getBool("inf_rebootESP") == true) {  // Получаем состояние "inf_rebootESP" (если нажато на WEB информировании да - true, нет - false)
        ESP.restart();                            // Перезагружаем ESP
        delay(2000);                              // Ждём для корректной перезагрузки
      }
    }

    //Выполняем действие после нажатия "ДА" на информ. окне - Сброс настроек ESP
    if (ui.click("inf_resetESP")) {              // Вернёт true, если был клик по кнопке информационного окошка "inf_resetESP"
      if (ui.getBool("inf_resetESP") == true) {  // Получаем состояние "inf_resetESP" (если нажато на WEB информировании да - true, нет - false)

        //Очистка EEPROM
        EEPROM.begin(EEPROM_BEGIN);                   // Инициализируем EEPROM
        for (byte rw = 0; rw < EEPROM_BEGIN; rw++) {  // Вычисляем размер EEPROM и проходим по всем ячейкам
          EEPROM.write(rw, 0);                        // Подготавливаем к записи нулей с 0 по "EEPROM_BEGIN" ячейки (сохраняем в ОЗУ)
          EEPROM.commit();                            // Записываем из ОЗУ в EEPROM
          EEPROM.end();                               // И очищаем данные из ОЗУ
        }
        ESP.restart();  // Перезагружаем ESP
        delay(2000);    // Ждём для корректной перезагрузки
      }
    }
  }
}